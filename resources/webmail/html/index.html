<!DOCTYPE html>
<html>
	<head>
		<title>Chainmail</title>
		<link rel="stylesheet" type="text/css" href="css/style.css" />
	</head>
	<body>
		<div class="container">
			<h1>Chainmail <small>minimal trust, configurable email</small></h1>
			<p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. In diam dui, euismod vel fringilla accumsan, pretium vehicula purus. Praesent diam augue, facilisis vel vestibulum porta, blandit et elit. Donec non velit id augue gravida semper. Nunc commodo felis rhoncus augue fringilla, id molestie diam venenatis. Donec scelerisque hendrerit tempor. Suspendisse vitae elementum eros, quis semper ipsum. Integer placerat eros tortor, sit amet feugiat nibh bibendum ac. Curabitur dignissim ac felis quis auctor. Sed pharetra a mi ac dapibus. Etiam vulputate et dui eget sodales. In sit amet purus ut leo tincidunt viverra. Nam tincidunt accumsan consequat. Maecenas vitae sem ipsum. Praesent scelerisque leo imperdiet ante lobortis sagittis.</p>

			<p> Curabitur eget lorem lorem. Mauris vitae sem in mauris elementum ultricies ut molestie urna. Sed suscipit adipiscing urna, ut laoreet lorem blandit sed. Aliquam ipsum sapien, porttitor vitae lacus nec, fermentum tempor quam. Morbi et leo orci. Nullam at tortor eget sapien molestie ultricies. Cras ut lorem quam. Nulla eleifend turpis justo, a hendrerit nisl tempus ut. Duis vel ante quis lorem tincidunt suscipit quis nec nulla. Ut dolor dui, cursus id arcu et, consequat blandit turpis.</p>

			<p> Maecenas vitae elit eget turpis convallis mattis. Etiam in posuere eros. Duis eleifend augue velit, nec laoreet neque pulvinar sit amet. Curabitur tempus pellentesque euismod. Pellentesque in congue sapien. Praesent sit amet tristique enim. Cras ut quam massa.</p>

			<p>Nam lacinia tortor in est porta commodo. Aenean ut felis eleifend mauris commodo interdum. Phasellus ipsum quam, aliquam vitae magna non, dignissim feugiat orci. Aliquam massa ipsum, pulvinar ut pellentesque ac, iaculis a purus. Sed eu semper mi. Quisque porta ornare nisl id lacinia. Morbi vel aliquam elit, vitae convallis erat. Vivamus ac est id massa dapibus dictum sed a nibh. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Duis et erat in neque feugiat imperdiet id ut lacus. Donec lectus nibh, auctor eu enim id, vestibulum laoreet ligula. Pellentesque commodo eget ipsum quis ullamcorper. Aliquam sit amet dolor ipsum. Integer erat ligula, rhoncus ac sollicitudin et, fringilla id est. Pellentesque pretium imperdiet placerat.</p>
		</div>

		<canvas id="bg"></canvas>

		<script type="text/javascript">
			RING_RADIUS = 15
			RING_THICKNESS = 3
			RING_SPACE = 10
			LINK_ELASTICITY = 1
			MAGIC_DISTANCE = Math.sqrt(Math.pow(RING_RADIUS + RING_SPACE/2, 2) * 2)
			MAGIC_ADVERSARIAL_DISTANCE = RING_RADIUS + RING_SPACE
			MAX_DISTANCE = 30
			SHIFT_WIDTH = RING_RADIUS + RING_THICKNESS 
			GRAVITY = 0 // Pixels per second persecond
			DRAW_VECTORS = false
			DRAWN_VECTOR_SCALE = 30
			DRAW_LINKS = true
			AIR_FRICTION = 1
			C = 0

			function hex(dec) {
				var ret = []
				while (dec >= 16) {
					ret.unshift(dec % 16)
					dec = Math.floor(dec/16)
				}
				ret.unshift(dec)

				var hexString = ret.map(function(c) {
					if (c < 10) return c.toString()
					else return String.fromCharCode(c + 87)
				}).join('')

				return hexString
			}

			function Ring(x, y, fixed) {
				// position
				this.x = x
				this.y = y

				// "force"
				this.fx = 0
				this.fy = GRAVITY

				// velocity
				this.vx = 0
				this.vy = 0

				this._fixed = fixed
				this.neighbors = []
				this.adversaries = []

				this.draw = function (ctx) {
					ctx.beginPath()
					ctx.arc(this.x, this.y, RING_RADIUS, 0, 2*Math.PI)
					ctx.stroke()

					if (DRAW_VECTORS) {
						this._drawVector(this.vx, this.vy, "red")
						this._drawVector(this.fx, this.fy, "blue")
					}
					if (DRAW_LINKS) {
						for (var i=0; i<this.neighbors.length; i++) {
							var n = this.neighbors[i]

							ctx.strokeStyle = "black"
							ctx.lineWidth = 1

							ctx.beginPath()
							ctx.moveTo(this.x, this.y)
							ctx.lineTo(n.x, n.y)
							ctx.stroke()

							ctx.strokeStyle = "grey"
							ctx.lineWidth = RING_THICKNESS
						}
					}
				}

				this._drawVector = function(vx, vy, color){
					ctx.strokeStyle = color
					ctx.lineWidth = 1

					var tx = this.x + (vx * DRAWN_VECTOR_SCALE),
						ty = this.y + (vy * DRAWN_VECTOR_SCALE)

					ctx.beginPath()
					ctx.moveTo(this.x, this.y)
					ctx.lineTo(tx, ty)
					ctx.stroke()

					ctx.strokeStyle = "grey"
					ctx.lineWidth = RING_THICKNESS
				}

				this.update = function(t) {
					// If the ring is fixed (probably in the top row) we don't need to
					// bother with physics calculations for it.
					if (this._fixed) return

					var accx = 0,
						accy = 0

					for (var i=0; i<this.neighbors.length; i++) {
						var n = this.neighbors[i]

						accx += (n.x - this.x)
						accy += (n.y - this.y)
					}

					this.x += accx/this.neighbors.length
					this.y += accy/this.neighbors.length

					return
					// First update force values. All rings experienfalsece force from their
					// neighbors and from gravity.
					this.fx = 0
					this.fy = GRAVITY

					for (var i=0; i<this.neighbors.length; i++) {
						var n = this.neighbors[i],
							d = dist(this, n),
							theta = Math.atan2(n.y - this.y, n.x - this.x),
							cosT = Math.cos(theta),
							sinT = Math.sin(theta)

						// When 0, there is no elastic foce working on the ring
						var magicDist = d - MAGIC_DISTANCE

						this.fx += absMin(cosT * magicDist/1, 100)
						this.fy += absMin(sinT * magicDist/1, 100)
					}

					// Based on the net force working on the ring, accelerate it. Everything
					// has the same mass so we're going to pretend like I'm not forgetting
					// highschool physics and ignore it.
					this.vx += absMin((this.fx - this.vx * AIR_FRICTION) * t, 100)
					this.vy += absMin((this.fy - this.vy * AIR_FRICTION) * t, 100)
					//this.vx = this.fx
					//this.vy = this.fy

					// And now actually move the damn thing
					this.x += this.vx * t
					this.y += this.vy * t
				}

				this.meetTheNeighbor = function(n) {
					this.neighbors.push(n)
					n.neighbors.push(this)
				}
			}

			function dist(obj1, obj2) {
				return Math.sqrt(Math.pow(obj2.x - obj1.x, 2) + Math.pow(obj2.y - obj1.y, 2))
			}

			function absMin(v1, v2) {
				// Return the value with the minimum abs. value and the sign of v1
				var a1 = Math.abs(v1),
					a2 = Math.abs(v2)

				if (a1 > a2) {
					return v2 * (v1/a1)
				} else {
					return v1
				}
			}

			var height = document.documentElement.clientHeight,
				width = document.documentElement.clientWidth,
				canvas = document.getElementById('bg'),
				ctx = canvas.getContext('2d'),
				numCols = Math.floor( width/(RING_RADIUS*2 + RING_SPACE) ),
				numRows = Math.floor( height/(RING_RADIUS + RING_SPACE/2) ),
				rings = [],
				ringGrid = []

			canvas.width = width
			canvas.height = height

			ctx.strokeStyle = "grey"
			ctx.lineWidth = RING_THICKNESS

			var shifted = true
			for (var row=0; row<numRows; row++) {
				shifted = !shifted
				ringGrid.push([])

				for (var col=0; col<numCols; col++) {
					var cx = col * (RING_RADIUS*2 + RING_SPACE) + RING_RADIUS/2 + (shifted?SHIFT_WIDTH:0),
						cy = row * RING_RADIUS + RING_RADIUS/2,
						fixed = row==0 || col==0 || col==numCols-1 || row==numRows-1,
						r = new Ring(cx, cy, fixed)

					/* GRID          ARRANGEMENT
             c1|c2|c3
					r1  a  b  c          a   b   c
					r2  d  e  f        d   e   f
					r3  h  i  j          h   i   j   */

					ringGrid[row][col] = r

					var neighbors = []
					if (ringGrid[row-1])
						neighbors.push(ringGrid[row-1][col])

					if (shifted) {
						if (ringGrid[row-1])
							neighbors.push(ringGrid[row-1][col+1])
					} else {
						if (ringGrid[row-1])
							neighbors.push(ringGrid[row-1][col-1])
					}

					neighbors = neighbors.filter(function(x) { return x })
					for (var i=0; i<neighbors.length; i++) {
						neighbors[i].meetTheNeighbor(r)
					}

					rings.push(r)
				}
			}

			;(function tick(last) {
				console.log('tick.')
				var current = Date.now(),
					dt = (current - last)/1000 // We work in units-per-second around here

				ctx.fillStyle = "white"
				ctx.fillRect(0, 0, width, height)
				for (var i=0; i<rings.length; i++) {
					var ring = rings[i]

					ring.update(dt)
					ring.draw(ctx)
				}

				// Wrap in a closure so we can give it the current value
				window.setTimeout(function() { tick(current) }, 10) 
			})//(Date.now())

		</script>
	</body>
</html>